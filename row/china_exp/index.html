<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://restofworld.org/wp-content/themes/orbis/static-assets/external/fonts.css">


    <title>D3.js Map</title>
    <style>
        path {
            stroke: #fff;
            stroke-width: 0.5;
        }

        .point {
            stroke: #fff;
            stroke-width: 0.5;
        }


    .grabbing {
      cursor: grabbing;
    }
    
    .filter.selected {
        color: #fff;
        background-color: #E45E00;
    }
    
    p.description {
        font-size: 16px;
        margin: 5px 0;
    }
    
    p.attr {
        font-size: 14px;
    }
    
    #filter-container {
        display: flex;
        gap: 10px;
        justify-content: center;
    }
    
    .filter {
        /* display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center; */
        padding: 7px 11px 6px;
        font-size: 13px;
        line-height: 13px;
        border-radius: 10px;
        border: none;
        background: #fff;
        width: max-content;
        /* transition: all .2s ease; */
        white-space: nowrap;
        cursor: pointer;
        user-select: none;
        border: 1px solid black;
        text-transform: uppercase;
        font-family: "Input Mono", sans-serif;
        transition: all 0.2 ease;

    }
    
    #All:hover:not(.selected) {
        background-color: rgba(0,0,0,0.5);
    }
    #Shein:hover:not(.selected) {
        background-color: #D3221650;
    }
    
    #Temu:hover:not(.selected){
        background-color: #EF7F3150;
    }
    
    #TikTok:hover:not(.selected) {
        background-color: #9F7DFF50;
    }
    
    #Alibaba:hover:not(.selected) {
        background-color: #FF97FE50;
    }

    .selected {
        border: none;
    }
    
    #All.selected {
        color: #fff;
        background-color: #000;
    }
    
    #Shein.selected {
        color: #fff;
        background-color: #D32216;
    }
    
    #Temu.selected {
        color: #fff;
        background-color: #EF7F31;
    }
    
    #TikTok.selected {
        color: #fff;
        background-color: #9F7DFF;
    }
    
    #Alibaba.selected {
        color: #fff;
        background-color: #FF97FE;
    }
    
    
          h1, h2, p{
        font-family: "Moderat",sans-serif;
      }
    
      h1 {
        font-size: 20px;
        text-align: center;

      }
    
      h2 {
        font-size: 14px;
        color: #666;
        font-weight: 400;
      }
    
    
      div.container {
        margin: 0;
        display: inline-block;
        width: fit-content;
      }
    
      div.table {
        padding: 0;
        display: flex;
        width: fit-content;
        flex-wrap: wrap;
      }
    
      div.table > p {
        margin: 5px 0;
        flex: 0 0 calc(50% - 10px);
      }
    
      span.label {
        font-size: 11px;
        display: block;
        color: #494949
      }

      .line {
        stroke-width: 1;
      }
    
        #tooltip {
            background-color: white;
            padding: 10px;
            border: 1px solid #a8a8a8;
            /* border-top: 5px solid #E45E00; */
            border-top: 5px solid black;
            border-radius: 4px;
            display: inline-block;
            position: fixed;
            width: 250px;
        }
        circle {
            cursor: pointer;
        }
        #body-container {
    width: 100%;
    max-width: 980px; /* Set a max-width to control the map's maximum size */
    
}
#map-container {
    width: inherit;
  overflow-x: auto; /* Enable horizontal scrolling */
  white-space: nowrap; /* Prevent SVG from wrapping to a new line */
}

#map {
  margin-top: 10px;
  display: block;
  margin: 0 auto;
  overflow-x: auto; /* Enable horizontal scrolling */

  width: 980px;
    height: inherit; /* Make the height responsive based on the width */
}

p.dek {
    font-size: 14px;
    color: #666;
    text-align: center;
    margin-bottom: 10px;
  }

  p.cta {
    text-align: center;
    font-size: 12px;
    font-weight: bold;
  }
  p.credit {
    font-family: "Input Mono",monospace;
    font-size: 10px;
    text-align: right;
    max-width: 500px;
    display: block;
    margin-left: auto; 
margin-right: 0;
  }

    </style>
</head>
<body>
    <div id="body-container">
        <h1>Moving away from China</h1>
        <p class="dek">Chinese e-commerce companies have become more international, both to operate closer to their customers, and to avoid anti-Chinese scrutiny.</p>
        <div id="filter-container"></div>
        <div id="tooltip" style="display: none;"></div>
        <p class="cta">Hover over dots for more infomation</p>
        <div id="map-container">
            <svg id="map"></svg>
        </div>
        <p class="credit">Source: News reports</p>
        <p class="credit">Data research: Sherry Xiao</p>
          </div>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <script>

function drawMap(){

    let svg_container = d3.select("#map"),
    width = 980,
    height = 450



// Create an SVG element and set its dimensions
// const width = window.innerWidth;
// const height = window.innerHeight;

const chinaCenter = [104.1954, 35.8617]; 

const svg = svg_container
    .attr("width", width)
    .attr("height",height)

    let colorDict = {
    "Shein":"#D32216",
    "Temu":"#EF7F31",
    "TikTok":"#9F7DFF",
    "Alibaba":"#FF97FE"
}

// Create a Mercator projection for the map
const projection = d3.geoNaturalEarth1(); //.rotate([-100, -15]);

// Create a path generator
const path = d3.geoPath().projection(projection);

function returnData(d){


return `<div class="container ${d.Grouping}">
    <p class="description">${d.Description}</p>   
    <div class="table">
    <p class="attr"><span class="label">App</span> ${d.App}</p>
    <p class="attr"><span class="label">Company</span> ${d['Parent company']}</p>    
    <p class="attr"><span class="label">Location</span> ${d.Location}</p>   
    <p class="attr"><span class="label">Year</span> ${d.Year}</p>   
    <p class="attr"><span class="label">Function</span> ${d.Classification}</p>  
    </div>
 </div>
    `
}

let filterContainer = document.getElementById('filter-container');


function makeButtons(companyNames) {
            let element = 'All'
            let button = document.createElement('button');
                button.className = `filter selected`;
                button.id = `${element}`;
                button.textContent = element;
                filterContainer.appendChild(button);

            for (let index = 0; index < companyNames.length; index++) {
                let element = companyNames[index];
                let button = document.createElement('button');
                button.className = `filter`;
                button.id = `${element}`;
                button.textContent = element;
                filterContainer.appendChild(button);
            }

        }




function hideTooltip() {
    d3.select("#tooltip")
        .style("display", "none");
}






// Load the world map data
d3.json("world_2.json").then(function (world) {
    // Append the countries to the SVG
    svg.selectAll("path")
        .data(world.features)
        .enter()
        .append("path")
        .attr("d", path)
        .attr('fill',(d) => (d.properties.name == 'China' ? "#000" : "#d4d4d4"))


        function showTooltip(d) {
    // Get the coordinates for the tooltip
    var [x, y] = return_Centeroid(d.Location);




    // Show the tooltip at the coordinates

    let containerWidth = document.getElementById('map-container').clientWidth / 2;
    

    if (document.getElementById('map-container').clientWidth < 980) {
        d3.select("#tooltip")
        .style("display", "block")
        .style("left", (x - (containerWidth - 70)) + "px")
        .style("top", (y + 100) + "px")
        .html(returnData(d));
    }
    else {
        if (x >= containerWidth){
        d3.select("#tooltip")
        .style("display", "block")
        .style("left", (x - 280) + "px")
        .style("top", (y + 20) + "px")
        .html(returnData(d));
        }
        else {
            d3.select("#tooltip")
            .style("display", "block")
            .style("left", (x + 20) + "px")
            .style("top", (y + 20) + "px")
            .html(returnData(d));

        }

    }




}

let listOfCountries = [];


        function return_Centeroid(country_name){

            let padding = 0;

            let paddingBase = 5;
            
            const count = listOfCountries.reduce((accumulator, currentValue) => {
            if (currentValue === country_name) {
                console.log(country_name)
                return accumulator + 1;
            }
            return accumulator;
            }, 0);




            if (count >= 1) {
            // Value exists in the array

                if(count >= 2) {
                    padding = -paddingBase;
                }
                else {
                    padding = paddingBase;
                }
            } else {
            // Value does not exist in the array
                padding = 0;
            }

            listOfCountries.push(country_name);



simp_country = world.features.find(function(nation) {
    return nation.properties.name === country_name;
});

console.log("count",count);

country = path.centroid(simp_country)
console.log(country[0]);
country[0] += padding;
console.log(country[0],country_name);
return country;


}

function redrawDots(data){

svg.selectAll(".point").remove();

svg.selectAll(".line").remove();



    function getArch(source,target) {
        var dx = target[0] - source[0],
            dy = target[1] - source[1],
            dr = Math.sqrt(dx * dx + dy * dy)  * 0.65;
        return "M" + source[0] + "," + source[1] + "A" + dr + "," + dr +
    " 0 0,1 " + target[0] + "," + target[1];
    }

    var previousCoordinatesLineX = {};

    svg.selectAll(".line")
    .data(data,  function(d) {
        return d.Location + d.Grouping; // Use Location and Grouping as the key
    })
    .enter()
    .append("path")
    .attr("class", "line")
    .attr("d", function(d) {
        var coords = return_Centeroid(d.Location);

        if (previousCoordinatesLineX[d.Location]) {
      // Spread the new point 5 pixels around the previous point
            coords[0] = previousCoordinatesLineX[d.Location][0] + 2;

        }

        // Store the current coordinates as the previous coordinates
        previousCoordinatesLineX[d.Location] = coords;

            return getArch(projection(chinaCenter),coords);
        })
    .style("stroke", function (d) { return colorDict[d.Grouping]})
    .style('fill',"none");

    var previousCoordinates = {};


    var points = svg.selectAll(".point")
    .data(data,  function(d) {
        return d.Location + d.Grouping; // Use Location and Grouping as the key
    })
    .enter()
    .append("circle")
    .attr("class", "point")
    .attr('data-city', (d) => d.Location)
    .attr("r", 5)    
    .attr("cx", function (d) {
    var coords = return_Centeroid(d.Location);

        // Check if coordinates for this location were used before
    if (previousCoordinates[d.Location]) {
      // Spread the new point 5 pixels around the previous point

      if(d.Location == "Singapore"){
        coords[0] = previousCoordinates[d.Location][0] + 5;
      }
      else{
        coords[0] = previousCoordinates[d.Location][0] + 10;
      }

    }

    // Store the current coordinates as the previous coordinates
    previousCoordinates[d.Location] = coords;


    return coords[0]; // Set the X-coordinate using cx
  })
  .attr("cy", function (d) {
    var coords = return_Centeroid(d.Location);
    return coords[1]; // Set the Y-coordinate using cy
  })
            
    // .attr("transform", function (d) {
    // var coords = return_Centeroid(d.Location);
    // return "translate(" + return_Centeroid(d.Location) + ")";
    // })
    .style("fill", function (d) { return colorDict[d.Grouping]})

    const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

    if (isTouchDevice) {
    // Handle touch events (e.g., tap or touchstart)
    svg.selectAll(".point").on('touchstart', function (event, d) {
    showTooltip(d);
    });
    } else {
    // Handle mouse events (e.g., mouseover)
    svg.selectAll(".point")
    .on("mouseover", function (event, d) {
    showTooltip(d);
    })
    .on("mouseout", hideTooltip);
        // Your mouse event handling logic here
    };
    








}



        d3.csv("sites.csv").then( function(markers){

let uniqueGroupings = [];

markers.forEach(item => {
// Step 3: Check if the 'grouping' value is not already in the uniqueGroupings array
    if (!uniqueGroupings.includes(item.Grouping)) {
        // Step 4: Add the 'grouping' value to the uniqueGroupings array
        uniqueGroupings.push(item.Grouping);
    }
});

if (filterContainer.innerHTML.trim() === "") {
    makeButtons(uniqueGroupings);
}


let buttons = document.querySelectorAll('.filter');

buttons.forEach(button => {
    button.addEventListener('click', () => {
        const selectedGrouping = button.getAttribute('id');

        // Filter the dataset based on the selected grouping

        buttons.forEach(btn => btn.classList.remove('selected'));

        button.classList.add('selected');

        let filteredData = [];

        if (selectedGrouping == "All") {
            filteredData = markers
        }
        else {
            filteredData = markers.filter(item => item.Grouping === selectedGrouping);
        }



        // Redraw the dots with the filtered data
        redrawDots(filteredData);

    });
});

redrawDots(markers);

        });
});

}

let resizeTimer;


window.addEventListener("resize", function(){
  clearTimeout(resizeTimer);
  parent.postMessage(document.body.clientHeight, "*")

  resizeTimer = setTimeout(function () {
    document.getElementById("map").innerHTML = "";
    drawMap();
  }, 100);
});

drawMap();
parent.postMessage(document.body.clientHeight, "*")


    </script>
</body>

</html>
