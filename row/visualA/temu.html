<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Parallel Chart</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
      /* Add your CSS styles here */
      .line {
        fill: none;
        stroke-width: 2;
        cursor: pointer;
      }

      .axis line, .axis text, g.tick {
        opacity: 1;
        /* display: none; Hide tick marks and axis lines */

      }

      #temu {
        width: 100%;
        max-width: 600px;
        height: 90vh;
        max-height: 800px;
      }


      g.tick > line {
        stroke: #afafaf;
      }

      .hover-text {
        font-size: 12px;
        text-anchor: middle;
      }


      

    </style>
  </head>
  <body>
    <div id="temu"></div>
    <script>

      // Data for your parallel coordinates chart
      const data = [
  {
    name: "Australia",
    attr1: 225400,
    attr2: 2961542,
  },
  {
    name: "Belgium",
    attr1: 7095,
    attr2: 730180,
  },
  {
    name: "Canada",
    attr1: 1849423,
    attr2: 3980334,
  },
  {
    name: "France",
    attr1: 2809,
    attr2: 5395460,
  },
  {
    name: "Germany",
    attr1: 22550,
    attr2: 6822943,
  },
  {
    name: "Italy",
    attr1: 39142,
    attr2: 5357205,
  },
  {
    name: "Japan",
    attr1: 1,
    attr2: 2920755,
  },
  {
    name: "Mexico",
    attr1: 86734,
    attr2: 12359935,
  },
  {
    name: "Netherlands",
    attr1: 11601,
    attr2: 1086326,
  },
  {
    name: "Poland",
    attr1: 7631,
    attr2: 1667558,
  },
  {
    name: "Portugal",
    attr1: 2974,
    attr2: 758265,
  },
  {
    name: "Spain",
    attr1: 21095,
    attr2: 3955503,
  },
  {
    name: "Sri Lanka",
    attr1: 1,
    attr2: 1769249,
  },
  {
    name: "United Kingdom",
    attr1: 195817,
    attr2: 7492687,
  },
  {
    name: "United States",
    attr1: 31225222,
    attr2: 56699638,
  },
];

function drawChart(){

let svg_container = d3.select("#temu"),
    temp_width = svg_container.node().clientWidth,
    temp_height = svg_container.node().clientHeight;


      const margin = { top: 30, right: 30, bottom: 30, left: 60 };
      const width = temp_width - margin.left - margin.right;
      const height = temp_height - margin.top - margin.bottom;

      const svg = svg_container
        .append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom)
        .append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);


      // Define the dimensions (attributes) you want to visualize
      const dimensions = Object.keys(data[0]).filter(key => key !== 'name');

      // Set a consistent domain for all dimensions
      const commonDomain = [d3.max(data, d => d.attr2), 0]; // Adjust the domain based on your data range


     const customTickValues = [0, 4000000,8000000,12000000];

        // const customTickFormat = d3.formatPrefix(".0", 1e6);

        // let dotDim = d3.scaleLog()
        //     .domain([d3.max(data, d => d.attr2), 1])
        //     .range([0, height / 2]);

            let dotDim = d3.scaleLinear()
            .domain(commonDomain)
            .range([0, height / 2]);



      // Create X scales for the left and right axes
      const xLeft = {};
      const xRight = {};
      dimensions.forEach((dim, i) => {
        // xLeft[dim] = d3.scaleLog()
        //   .domain([d3.max(data, d => d.attr2), 1])
        //   .range([0, height / 2]);

        // xRight[dim] = d3.scaleLog()
        //   .domain([d3.max(data, d => d.attr2), 1])
        //   .range([0, height / 2]);


        xLeft[dim] = d3.scaleLinear()
          .domain(commonDomain)
          .range([0, height / 2]);

        xRight[dim] = d3.scaleLinear()
          .domain(commonDomain)
          .range([0, height / 2]);


          svg.append('g')
    .attr('class', 'axis')
    .attr('transform', `translate(${i * (width / (dimensions.length - 1)), 0})`)
    // .call(d3.axisLeft(xLeft[dim]).tickValues(customTickValues))
    .call(d3.axisLeft(xLeft[dim]))
    .select('.domain').remove()

    svg.selectAll('g.tick > line')
    .attr('x2', width); // Extend the tick lines to span the entire chart





      });

      // Create a line generator for each data point
      const line = d3.line()
        .x((d, i) => i * (width / (dimensions.length - 1)))
        .y((d, i) => i < 3 ? xLeft[dimensions[i]](d) : xRight[dimensions[i]](d));

        const hoverText = svg.append('text')
        .attr('class', 'hover-text')
        .attr('x', width / 2)
        .style('text-anchor', 'middle')
        .style('font-size', '12px')
        .style('display', 'none'); // Initially hide the hover text



        let startCircles, endCircles;
      // Draw the lines
      const lines = svg.selectAll('.line')
        .data(data)
        .enter()
        .append('path')
        .attr('class', 'line')
        .attr('d', d => line(dimensions.map(dim => d[dim])))
        .style('stroke', "#E45E00")
        .on('mouseover', function (event, d) {

          lines.style('opacity', 0.3);
          startCircles.style('opacity', 0.3);

            endCircles.style('opacity', 0.3);

            // Highlight the hovered line
            d3.select(this).style('opacity', 1);
            d3.selectAll(`circle.${d.name.replace(' ','.')}`).style('opacity', 1);


          // Calculate the y-position based on whether the line is on the left or right axis
          const yPosition = event.target.classList.contains('line-left') ? xLeft[dimensions[dimensions.length - 1]](d[dimensions[dimensions.length - 1]]) - 10 : xRight[dimensions[dimensions.length - 1]](d[dimensions[dimensions.length - 1]]) - 10;

          // Show the name when hovering over the line
          hoverText
            .attr('y', yPosition)
            .text(d.name)
            .style('display', 'block');
        })
        .on('mouseout', function () {
          // Remove the name when not hovering over the line
          lines.style('opacity', 1);
          hoverText.style('display', 'none');
          startCircles.style('opacity', 1);
            endCircles.style('opacity', 1);

        });


// Redraw the circles at the start and end of the lines
startCircles = svg.selectAll('.circle-start')
  .data(data)
  .enter()
  .append('circle')
  .attr('class', 'circle-start')
  .attr('class', d => d.name)
  .attr('cx', d => 0) // X position at the start of the line
  .attr('cy', d => dotDim(d.attr1)) // Y position at the start of the line
  .attr('r', 4) // Radius of the circle
  .style('fill', '#E45E00'); // Fill color of the circle

endCircles =svg.selectAll('.circle-end')
  .data(data)
  .enter()
  .append('circle')
  .attr('class', 'circle-end')
  .attr('class', d => d.name)
  .attr('cx', width) // X position at the start of the line
  .attr('cy', d => dotDim(d.attr2)) // Y position at the start of the line
  .attr('r', 4) // Radius of the circle
  .style('fill', '#E45E00'); // Fill color of the circle

}

let resizeTimer;


window.addEventListener("resize", function(){
  clearTimeout(resizeTimer);

  resizeTimer = setTimeout(function () {
    document.getElementById("temu").innerHTML = "";
    drawChart();
    parent.postMessage(document.body.clientHeight, "*")
  }, 100);
});
parent.postMessage(document.body.clientHeight, "*")

drawChart();


    </script>
  </body>
</html>
