<!DOCTYPE html>	
<link rel="stylesheet" href="https://restofworld.org/wp-content/themes/orbis/static-assets/external/fonts.css">

<meta charset="utf-8">

<!-- Load d3.js -->
<script src="https://d3js.org/d3.v6.min.js"></script>

<body>
  <div class="topContainer">
    <h1>TikTok Shop GMV in Southeast from Oct 2022 to Aug 2023, by country</h1>
    <h2 id="date">October 2022</h2>
    <div class="slider-container">
      <button id="toggleButton">Play</button> <input type="range" id="monthSlider" min="0" max="10" step="1" value="0">
    </div>  
  </div>


<!-- Create an element where the map will take place -->
  <svg id="my_dataviz" width="660" height="500"></svg>

</body>


<script>

  // Define a function to update the map size





parent.postMessage(document.body.clientHeight, "*")

let dateHeader = document.getElementById('date');

let svg = d3.select("svg#my_dataviz"),
    width = +svg.attr("width"),
    height = +svg.attr("height");

//     let viewBox = "600 300 360 500";

// svg.attr("viewBox", viewBox);



//     function updateMapSize() {
//    width = window.innerWidth;
//    height = window.innerHeight;

//   // Set the SVG's width and height based on the window dimensions
//   svg.attr("width", width)
//      .attr("height", height);


// }

// // Call the function to set the initial size
// updateMapSize();

// // Attach an event listener for window resize

// window.onresize = updateMapSize;


let country_data = []
let path;
let filter_num = 0;

let circle_radius = 60;


d3.json("countries.geojson").then( function(countries){


country_data = countries.features;

const extent = [80.880885, 27.548636, 154.354626, -9.898752]; 

const projection = d3.geoNaturalEarth1().fitSize([width, height], countries)

// const projection = d3.geoNaturalEarth1()
//   .clipAngle(extent)
//   .fitSize([width, height], countries);


path = d3.geoPath().projection(projection)





let country_group = svg.append("g");
  country_group
    .selectAll("path")
    .data(countries.features)
    .join("path")
    .attr("d", path)
    // .attr("data-pop", (d) => console.log(d.properties.POP_EST))
    .attr("fill",(d) => (d.properties.selected === true ? "#999999" : "#eee"))
    .attr("stroke", "#fff")
    .attr("stroke-width", 1);


//     return Object.assign(svg.node(), {
//     update(data) {
//      if (data) {
//       bubble_group.data(data, d => d.name)
//           .sort((a, b) => d3.descending(a.bubbleSize, b.bubbleSize))
//           .attr("cx", d => x(d.xVariable))
//           .attr("cy", d => y(d.yVariable))
//           .attr("r", d => radius(d.bubbleSize));
       
//        bubble_group.on("mouseover", (event, d) => tooltip.show(d))
//           .on("mouseout", () => tooltip.hide())
//     }
//     }
//   });

function return_Centeroid(name){


  if (name == 'Singapore'){
    country = projection([103.8198,1.3521])
  }
  else {
    simp_country = country_data.find(function(person) {
      return person.properties.SOVEREIGNT === name;
    });

    country = path.centroid(simp_country)
  }

return country;

}


d3.csv("newData.csv").then( function(data){



    let parseDate = d3.timeParse('%m/%Y');

data.forEach(function(d) {
    d['gmv_RMB'] = +d['gmv_RMB'];
    // d.month_date = parseDate(d.month_date);
  });

  function onlyUnique(value, index, array) {
    return array.indexOf(value) === index;
  }


  let nuvalue = data.map(d => d.month_date)

  let nestedData = nuvalue.filter(onlyUnique);



  // let firstDate = nestedData[0];

  // let filteredData = data.filter(function(person) {
  //   return person.month_date >= firstDate;
  //   });



  let firstDate = nestedData[0];

let filteredData = data.filter(function(person) {
  return person.month_date == firstDate;
});


function formatNumberToShort(number) {
  const suffixes = ["", "k", "M", "B", "T"]; // Abbreviations for thousands, millions, billions, etc.
  let suffixNum = 0;

  while (number >= 1000 && suffixNum < suffixes.length - 1) {
    number /= 1000;
    suffixNum++;
  }

  // Round to 1 decimal place and add the abbreviation
  return number.toFixed(1) + suffixes[suffixNum];
}



let max_pop = d3.max(data.map((o) => o.gmv_RMB));
let bubble_group = svg.append("g");
bubble_group
.selectAll("circle")
.data(filteredData)
.join("circle")
// .attr("cx", (d) => return_Centeroid(d.SOVEREIGNT)[0])
// .attr("cy", (d) => return_Centeroid(d.SOVEREIGNT)[1])
.attr("cx", (d) => return_Centeroid(d.SOVEREIGNT)[0])
.attr("cy", (d) => return_Centeroid(d.SOVEREIGNT)[1])

// .transition(1000)
.attr("r", (d) => circle_radius * Math.sqrt(d.gmv_RMB / max_pop))
.attr("fill", "#E45E00")
.attr("opacity", 0.75);


let text_group = svg.append("g");

text_group
  .selectAll("text")
  .data(filteredData)
  .enter()
  .append("text")
  .attr("x", (d) => return_Centeroid(d.SOVEREIGNT)[0])
  .attr("y", (d) => return_Centeroid(d.SOVEREIGNT)[1])
  .attr("dy", 5) // Adjust the vertical position of the text
  .style("text-anchor", "middle") // Center the text horizontally
  .text((d) => formatNumberToShort(d.gmv_RMB));


function updateData(newData) {
      var bubble_group = svg.selectAll("circle")
        .data(newData);

        bubble_group
        .transition()
       .duration(200)  // Animation duration in milliseconds
        .attr("r", (d) => circle_radius * Math.sqrt(d.gmv_RMB / max_pop));


//         bubble_group.enter()
//         .append("circle")
//         .merge(bubble_group)
//         .attr("cx", (d) => return_Centeroid(d.SOVEREIGNT)[0])
//       .attr("cy", (d) => return_Centeroid(d.SOVEREIGNT)[1])
//   .attr("r", (d) => circle_radius * Math.sqrt(d.gmv_RMB / max_pop))
//   .attr("fill", "#E45E00")
// .attr("opacity", 0.75);

// bubble_group.exit().remove();

            var text_group = svg.selectAll("text").data(newData);



            text_group.enter()
  .append("text")
  .merge(text_group)
  .attr("x", (d) => return_Centeroid(d.SOVEREIGNT)[0])
  .attr("y", (d) => return_Centeroid(d.SOVEREIGNT)[1])
  .attr("dy", 5) // Adjust the vertical position of the text
  .style("text-anchor", "middle") // Center the text horizontally
  .text((d) => formatNumberToShort(d.gmv_RMB));

  text_group.exit().remove();




    }



      function returnDate(dateString) {
        const dateParts = dateString.split('-');
        const year = dateParts[0];
        const monthIndex = parseInt(dateParts[1]) - 1; // Adjust for zero-based index
        const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
        const month = monthNames[monthIndex];
        return `${month} ${year}`;
      }


        let monthSlider = document.getElementById("monthSlider");

  // Function to update the selected month and trigger animation

  let monthIndex = 0;
  let nu_value;

  

  function updateMonth() {
    monthIndex = parseInt(monthSlider.value);
    firstDate = nestedData[monthIndex];
    // dateHeader.innerHTML = returnDate(firstDate);
    // date.textContent = returnDate(firstDate);

    // filteredData = data.filter(function(person) {
    //   return person.month_date == firstDate;
    // });
    

    // Trigger your animation logic here based on the selected month
  }

  // Add an event listener to the slider input
  monthSlider.addEventListener("change", sliderChanged);

  let isSliderChange = false;

  function sliderChanged() {
    isSliderChange = true;
    doSomething();
  }
 

  // Initialize with the default month

  function nextMonth() {
    if (isSliderChange) {
      isSliderChange = false;
      filter_num = monthSlider.value;
    }
    else {
      monthSlider.value = (filter_num + 1) % 11;
      filter_num = (filter_num + 1) % 11;
    }
    // nu_value = (monthIndex + 1) % 10;
    // console.log(nu_value)
  }


          // clearInterval(intervalID);

  



      // const intervalID = setInterval(function() {}, 500);

    let intervalID = null;
    let isIntervalRunning = false;

    // Function to perform an action at a regular interval
    function doSomething() {

      nextMonth();

      firstDate = nestedData[filter_num];

dateHeader.innerHTML = returnDate(firstDate);

// dateHeader.innerHTML = firstDate;

filteredData = data.filter(function(person) {
  return person.month_date == firstDate;
});

updateData(filteredData);

    }

    // Function to start or stop the interval
    function toggleInterval() {
      if (isIntervalRunning) {
        clearInterval(intervalID);
        isIntervalRunning = false;
        toggleButton.textContent = "Play";
        
      } else {
        intervalID = setInterval(doSomething, 1000); // Start the interval (e.g., every 1 second)
        isIntervalRunning = true;
        toggleButton.textContent = "Pause";

      }
    }

    const toggleButton = document.getElementById("toggleButton");
    toggleButton.addEventListener("click", toggleInterval);






})





})





</script>

<style>
  h1, h2, p{
    font-family: "Moderat",sans-serif;
  }

  h1 {
    font-size: 20px;
  }

  h2 {
    font-size: 14px;
  }

  #date {
    font-weight: 100;
  }

  text {
   font-family:"Input Mono",sans-serif;
   /* text-shadow: 1px 1px 2px #cdcdcd; */
  }

  .slider-container {
  text-align: left;
  display: flex;
  align-items: center;
  gap: 5px;
  max-width: 650px;
}

input[type="range"] {
  width: 100%;
  background: #808080; /* Bar color */
  height: 2px; /* Bar height */
  border: none; /* Remove the default border */
  border-radius: 0; /* Remove rounded edges */
  cursor: pointer; /* Show pointer cursor */
  -webkit-appearance: none;
}

/* Style the slider thumb */
input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none; /* Hide default thumb appearance on Webkit browsers (Chrome, Safari) */
  width: 16px; /* Thumb width */
  height: 16px; /* Thumb height */
  background-color: #E45E00; /* Thumb color */
  border: 2px solid #808080; /* Thumb border color */
  border-radius: 50%; /* Make the thumb circular */
  cursor: pointer; /* Show pointer cursor */
  outline: none; /* Remove the blue highlight on focus */
  color: green;
}

input[type="range"]::-moz-range-thumb {
  width: 16px; /* Thumb width */
  height: 16px; /* Thumb height */
  background: #E45E00; /* Thumb color */
  border: 2px solid #808080; /* Thumb border color */
  border-radius: 50%; /* Make the thumb circular */
  cursor: pointer; /* Show pointer cursor */
  outline: none; /* Remove the blue highlight on focus */
}

input[type="range"]::-webkit-slider-runnable-track {
      height: 2px;
    }
    
    /* Set a specific color for the slider thumb (slider knob) */
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
    border: none;
    height: 16px;
    width: 16px;
    border-radius: 50%;
      margin-top: -7px;
    }

    /* For non-WebKit browsers */

    /* Additional styling for cross-browser compatibility */
    input[type="range"] {
      width: 100%; /* Set the desired width for the slider */
    }


</style>