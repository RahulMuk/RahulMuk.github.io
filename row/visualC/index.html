<!DOCTYPE html>	
<link rel="stylesheet" href="https://restofworld.org/wp-content/themes/orbis/static-assets/external/fonts.css">

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">


<!-- Load d3.js -->
<script src="https://d3js.org/d3.v6.min.js"></script>

<style>

.countryContainer {
  display: flex;
  font-family: "Input Mono", sans-serif;
  gap: 10px;
  align-items: center;
  justify-content: center;
  flex-wrap: wrap;
  width: 100%;
  margin: 15px 0;
}

.country {
  display: flex;
  align-items: center;
  gap: 5px;
  margin: 10px;
  font-size: 14px;


}

.circle {
  border-radius: 50%;
  width: 10px;
  height: 10px;
  margin-bottom: 3px;
}

  #map-container {
    width: 100%;
}

#map {
  margin-top: 10px;
    width: 100%;
   
}

h1, h2, p{
    font-family: "Moderat",sans-serif;
  }

  p.dek {
    font-size: 14px;
    color: #666;
    text-align: center;
    margin-bottom: 10px;
  }

  h1, h2, p.dek {
    text-align: center;
  }

  h1 {
    font-size: 20px;
  }

  h2#date {
    font-size: 14px;
    font-weight: 100;
    font-family: "Input Mono", sans-serif;
    margin-bottom: 0;
    margin-top: 20px;
  }

  #toggleButton {
    background-color: #fff;
    border: none;
    height: 20px;
    width: 20px;    
    position: relative;
    margin-right: 10px;
    border: 2px solid black;
    border-radius: 50%;
    padding: 20px;
    display: flex;
    align-content: center;
    justify-content: center;
    align-items: center;
  }

  #toggleButton:hover {
    cursor: pointer;
  }

  #imgID {
    height: inherit;
    width: inherit;
  }


  /* #map {
    margin-top: 10px;
    width: 100%;
    height: 400px;
    max-width: 980px;
  } */

  text {
   font-family:"Input Mono",sans-serif;
   /* text-shadow: 1px 1px 2px #cdcdcd; */
  }

  .slider-container {
  text-align: left;
  display: flex;
  align-items: center;
  gap: 5px;
  max-width: 650px;
  margin: 0 auto;
}

input[type="range"] {
  width: 100%;
  background: #808080; /* Bar color */
  height: 2px; /* Bar height */
  border: none; /* Remove the default border */
  border-radius: 0; /* Remove rounded edges */
  cursor: pointer; /* Show pointer cursor */
  -webkit-appearance: none;
}

/* Style the slider thumb */
input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none; /* Hide default thumb appearance on Webkit browsers (Chrome, Safari) */
  width: 16px; /* Thumb width */
  height: 16px; /* Thumb height */
  /* background-color: #E45E00; Thumb color */
  background-color: #000;
  border: 2px solid #808080; /* Thumb border color */
  border-radius: 50%; /* Make the thumb circular */
  cursor: pointer; /* Show pointer cursor */
  outline: none; /* Remove the blue highlight on focus */
  color: green;
}

input[type="range"]::-moz-range-thumb {
  width: 16px; /* Thumb width */
  height: 16px; /* Thumb height */
  background: #E45E00; /* Thumb color */
  border: 2px solid #808080; /* Thumb border color */
  border-radius: 50%; /* Make the thumb circular */
  cursor: pointer; /* Show pointer cursor */
  outline: none; /* Remove the blue highlight on focus */
}

input[type="range"]::-webkit-slider-runnable-track {
      height: 2px;
    }
    
    /* Set a specific color for the slider thumb (slider knob) */
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
    border: none;
    height: 16px;
    width: 16px;
    border-radius: 50%;
      margin-top: -7px;
    }

    /* For non-WebKit browsers */

    /* Additional styling for cross-browser compatibility */
    input[type="range"] {
      width: 100%; /* Set the desired width for the slider */
    }
    p.credit {
    font-family: "Input Mono",monospace;
    font-size: 10px;
    text-align: right;
    max-width: 500px;
    display: block;
    margin-left: auto; 
margin-right: 0;
  }

</style>

<body>
  <div id="map-container">

  <div class="topContainer">
    <h1>TikTok Shop’s Southeast Asian ascent</h1>
    <p class="dek">TikTok Shop’s Gross Merchandise Value, in USD, grew in each of its markets between October 2022 and August 2023.</p>
    <h2 id="date">October 2022</h2>
    <div class="slider-container">
      <button id="toggleButton"><img id="imgID" alt="play" src="Play.png"/></button> <input type="range" id="monthSlider" min="0" max="10" step="1" value="0">
    </div>  
    <div class="countryKey">
      <div class="countryContainer">
        <h3 class="country"><div class="circle" style="background-color: #EF7F31;"></div><div>Indonesia</div></h3>
        <h3 class="country"><div class="circle" style="background-color: #D32216;"></div><div>Vietnam</div></h3>
        <h3 class="country"><div class="circle" style="background-color: #FF97FE;"></div><div>Malaysia</div></h3>
        <h3 class="country"><div class="circle" style="background-color: #9F7DFF;"></div><div>Philippines</div></h3>
        <h3 class="country"><div class="circle" style="background-color: #3AB091;"></div><div>Singapore</div></h3>
        <h3 class="country"><div class="circle" style="background-color: #0043EF;"></div><div>Thailand</div></h3>
      </div>
    </div>
  </div>
  <svg id="map"></svg>
  <p class="credit">Note: The Indonesian government effectively banned TikTok Shop in early October when it told social media companies to halt direct sales on their platforms.</p>
  <p class="credit">Source: Tabcut.</p>
</div>

</body>


<script>

  // Define a function to update the map size



let dateHeader = document.getElementById('date');

let imageButton = document.getElementById('imgID');




function updateMapSize(){

  let country_data = []

  let path;


  let filter_num = 0;

let circle_radius = 60;




  let svg = d3.select("svg#map"),
    width = window.innerWidth,
    height = (window.innerWidth / 3);

    svg.attr("width", window.innerWidth)
   .attr("height", (window.innerWidth / 3));




d3.json("countries.geojson").then( function(countries){

  let intervalID = null;
    let isIntervalRunning = false;
    clearInterval(intervalID);



country_data = countries.features;

console.log("countries",country_data.length)

const extent = [80.880885, 27.548636, 154.354626, -9.898752]; 

const xmin = 80.880885;
const ymin = -9.898752;
const xmax = 150.769743;
const ymax = 27.548636;


// Calculate the center of the bounding box.
const centerX = 120;
const centerY = 5;
const maxWidth = 980;
const maxHeight = 400;


// Calculate the scale to fit the bounding box within the map dimensions.
const xScale = width / (xmax - xmin);
const yScale = height / (ymax - ymin);
const scale = Math.min(xScale, yScale);


const adjustedScale = (scale * Math.min(maxWidth / (xmax - xmin), maxHeight / (ymax - ymin))) * 5.7;


// const projection = d3.geoNaturalEarth1().fitSize([width, height], countries)

const projection = d3.geoMercator()
    .center([centerX,centerY])
    .scale(adjustedScale)
    .translate([width / 2, height / 2]);


// const projection = d3.geoNaturalEarth1()
//   .clipAngle(extent)
//   .fitSize([width, height], countries);


path = d3.geoPath().projection(projection)


let colorDict ={
  "Indonesia":"#EF7F31",
  "Vietnam":"#D32216",
  "Malaysia":"#FF97FE",
  "Philippines":"#9F7DFF",
  "Singapore":"#3AB091",
  "Thailand":"#0043EF"
} 




let country_group = svg.append("g");
  country_group
    .selectAll("path")
    .data(country_data)
    .join("path")
    .attr("d", path)
    // .attr("data-pop", (d) => console.log(d.properties.POP_EST))
    .attr("fill",(d) => (d.properties.selected === true ? `${colorDict[d.properties.SOVEREIGNT]}50` : "#eee"))
    .attr("stroke", (d) => colorDict[d.properties.SOVEREIGNT])
    .attr("stroke-width", 1);


//     return Object.assign(svg.node(), {
//     update(data) {
//      if (data) {
//       bubble_group.data(data, d => d.name)
//           .sort((a, b) => d3.descending(a.bubbleSize, b.bubbleSize))
//           .attr("cx", d => x(d.xVariable))
//           .attr("cy", d => y(d.yVariable))
//           .attr("r", d => radius(d.bubbleSize));
       
//        bubble_group.on("mouseover", (event, d) => tooltip.show(d))
//           .on("mouseout", () => tooltip.hide())
//     }
//     }
//   });

function return_Centeroid(name){


  if (name == 'Singapore'){
    country = projection([103.8198,1.3521])
  }
  else if (name == 'Thailand') {
    country = projection([98.968674,11.940922])
  }
  else {
    simp_country = country_data.find(function(person) {
      return person.properties.SOVEREIGNT === name;
    });

    country = path.centroid(simp_country)
  }

return country;

}

d3.csv("newData.csv").then( function(data){


    let parseDate = d3.timeParse('%m/%Y');

data.forEach(function(d) {
    d['gmv_RMB'] = +d['gmv_RMB'];
    // d.month_date = parseDate(d.month_date);
  });

  console.log("dots",data.length);

  function onlyUnique(value, index, array) {
    return array.indexOf(value) === index;
  }


  let nuvalue = data.map(d => d.month_date)

  let nestedData = nuvalue.filter(onlyUnique);



  // let firstDate = nestedData[0];

  // let filteredData = data.filter(function(person) {
  //   return person.month_date >= firstDate;
  //   });



  let firstDate = nestedData[0];

let filteredData = data.filter(function(person) {
  return person.month_date == firstDate;
});


function formatNumberToShort(number) {
  const suffixes = ["", "k", "M", "B", "T"]; // Abbreviations for thousands, millions, billions, etc.
  let suffixNum = 0;

  while (number >= 1000 && suffixNum < suffixes.length - 1) {
    number /= 1000;
    suffixNum++;
  }

  // Round to 1 decimal place and add the abbreviation
  return number.toFixed(1) + suffixes[suffixNum];
}


let max_pop = d3.max(data.map((o) => o.gmv_RMB));
let bubble_group = svg.append("g");
bubble_group
.selectAll("circle")
.data(filteredData)
.join("circle")
.attr("cx", (d) => return_Centeroid(d.SOVEREIGNT)[0])
.attr("cy", (d) => return_Centeroid(d.SOVEREIGNT)[1])

// .transition(1000)
.attr("r", (d) => circle_radius * Math.sqrt(d.gmv_RMB / max_pop))
.attr("fill", (d) => colorDict[d.SOVEREIGNT])
.attr("opacity", 0.75);


let text_group = svg.append("g");

text_group
  .selectAll("text")
  .data(filteredData)
  .enter()
  .append("text")
  .attr("x", (d) => return_Centeroid(d.SOVEREIGNT)[0])
  .attr("y", (d) => return_Centeroid(d.SOVEREIGNT)[1])
  .attr("dy", 5) // Adjust the vertical position of the text
  .style("text-anchor", "middle") // Center the text horizontally
  .text((d) => formatNumberToShort(d.gmv_RMB));


function updateData(newData) {
  const circles = bubble_group.selectAll("circle")
        .data(newData, (d) => d.SOVEREIGNT);

    // Update the existing circles
    circles
        .transition()
        .duration(200)  // Animation duration in milliseconds
        .attr("cx", (d) => return_Centeroid(d.SOVEREIGNT)[0])
        .attr("cy", (d) => return_Centeroid(d.SOVEREIGNT)[1])
        .attr("r", (d) => circle_radius * Math.sqrt(d.gmv_RMB / max_pop));

    // Handle the entering circles
    circles.enter()
        .append("circle")
        .attr("cx", (d) => return_Centeroid(d.SOVEREIGNT)[0])
        .attr("cy", (d) => return_Centeroid(d.SOVEREIGNT)[1])
        .attr("r", (d) => circle_radius * Math.sqrt(d.gmv_RMB / max_pop))
        .attr("fill", "#E45E00")
        .attr("opacity", 0.75);

          // Remove any exiting circles
    circles.exit().remove();


// Update the text elements based on new data
const textElements = text_group.selectAll("text")
  .data(newData);

textElements.enter()
  .append("text")
  .merge(textElements)
  .attr("x", (d) => return_Centeroid(d.SOVEREIGNT)[0])
  .attr("y", (d) => return_Centeroid(d.SOVEREIGNT)[1])
  .attr("dy", 5) // Adjust the vertical position of the text
  .style("text-anchor", "middle") // Center the text horizontally
  .text((d) => formatNumberToShort(d.gmv_RMB));

textElements.exit().remove();




    }



      function returnDate(dateString) {
        const dateParts = dateString.split('-');
        const year = dateParts[0];
        const monthIndex = parseInt(dateParts[1]) - 1; // Adjust for zero-based index
        const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
        const month = monthNames[monthIndex];
        return `${month} ${year}`;
      }


        let monthSlider = document.getElementById("monthSlider");

  // Function to update the selected month and trigger animation

  let monthIndex = 0;
  let nu_value;

  

  function updateMonth() {
    monthIndex = parseInt(monthSlider.value);
    firstDate = nestedData[monthIndex];
    // dateHeader.innerHTML = returnDate(firstDate);
    // date.textContent = returnDate(firstDate);

    // filteredData = data.filter(function(person) {
    //   return person.month_date == firstDate;
    // });
    

    // Trigger your animation logic here based on the selected month
  }

  // Add an event listener to the slider input
  monthSlider.addEventListener("change", sliderChanged);

  let isSliderChange = false;

  const sliderValue = 0;

  function sliderChanged() {
    clearInterval(intervalID); // Clear the interval
    isIntervalRunning = false;
    isSliderChange = true;
    imageButton.src = "Play.png"

    const sliderValue = monthSlider.value;

    nextMonth();

    firstDate = nestedData[sliderValue];

    console.log(firstDate);

    dateHeader.innerHTML = returnDate(firstDate);

    // dateHeader.innerHTML = firstDate;

    filteredData = data.filter(function(person) {
      return person.month_date == firstDate;
    });


    updateData(filteredData);

  }
 

  // Initialize with the default month

  function nextMonth() {
    if (isSliderChange) {
      isSliderChange = false;
      filter_num = monthSlider.value;
    }
    else {
      filter_num = (filter_num + 1) % 11;
      monthSlider.value = filter_num;
    }
    // nu_value = (monthIndex + 1) % 10;
    // console.log(nu_value)
  }


          // clearInterval(intervalID);

  



      // const intervalID = setInterval(function() {}, 500);


    let timeToRun = 1000;

    // Function to perform an action at a regular interval
    function doSomething() {

      nextMonth();

      firstDate = nestedData[filter_num];



      dateHeader.innerHTML = returnDate(firstDate);

      // dateHeader.innerHTML = firstDate;

      filteredData = data.filter(function(person) {
        return person.month_date == firstDate;
      });


      updateData(filteredData);


      if(firstDate == nestedData[nestedData.length - 1]){
        clearInterval(intervalID); // Clear the interval
        isIntervalRunning = false;
        imageButton.src = "Play.png"
      }

    }

    // Function to start or stop the interval
    function toggleInterval() {
      if (isIntervalRunning) {
        clearInterval(intervalID);
        isIntervalRunning = false;
        imageButton.src = "Play.png"
        
      } else {
        intervalID = setInterval(doSomething, timeToRun); // Start the interval (e.g., every 1 second)
        isIntervalRunning = true;
        imageButton.src = "Pause.png"

      }
    }

    const toggleButton = document.getElementById("toggleButton");
    toggleButton.addEventListener("click", toggleInterval);






})





})



}

let resizeTimer;


window.addEventListener("resize", function(){
  clearTimeout(resizeTimer);
  parent.postMessage(document.body.clientHeight, "*")

  resizeTimer = setTimeout(function () {
    document.getElementById("map").innerHTML = "";
    updateMapSize();
  }, 100);
});

updateMapSize();
parent.postMessage(document.body.clientHeight, "*")


</script>

<style>



</style>